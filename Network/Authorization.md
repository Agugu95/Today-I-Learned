# HTTP Authorization  
- HTTP 인증
  - 기본인증  
  - Base64 Encoding  
  - Proxy Authorization  
  - Digest Authorization
- HTTP 보안  
  - SSL  
  - TLS  
  - HTTPS  
  - 암호화 Key  
    - 대칭키  
    - 비대칭키  
    - 공개키  
    - 인증서  
    - 서명  

## HTTP 인증  
HTTP 프로토콜을 통해 이동되는 수많은 데이터, 서버, 클라이언트들은 자신을 증명할 수단이 필요하다.  
  - 기본 인증  
  HTTP 프로토콜 자체에서 제공해주는 인증 방식으로 WWW-Authentication 헤더를 통해 사용자의 이름과 인코딩 된 비밀번호를 얻는다.  
  
  - Base64 Encoding  
  이러한 비밀번호를 전송할 때 사용자의 데이터가 유출되지 않게 하기위해 인코딩을 통해 암호화하는 작업이 필요하고  
  간단한 인코딩 작업에 사용되는 것이 Base64로 기존의 8비트 바이트 데이터를 순차 6비트로 변환하면서 문자와 숫자로 이루어진 64개 중에서 선택하여 만든다.  
  예로 "aaaaa" 5byte 데이터를 6bit씩 분할하여 ASCII 중에서 랜덤하게 선택된 문자로 변환된다.  
  8bit 데이터를 6bit씩 자르기때문에 최종 결과물은 실제 데이터보다 늘어나게 된다.  
  그런데 Base64의 경우 인코딩 된 데이터를 그대로 디코딩하면 데이터가 나오기 때문에 실제로는 비밀번호를 노출한 것과 다름없다.  
  
  - Proxy 인증  
  프록시 서버를 이용하여 요청이 반드시 인증을 거쳐가야 하도록 만들 수 잇다.  
  
  - Digest 인증  
  다이제스트 인증은 반드시 데이터를 요약(digest)해서 보내자는 인증방법이지만 트랜잭션 자체를 암호화 시키는 HTTPS에 밀려 거의 쓰이지 않는다.  
  
## HTTP 보안  
데이터를 보호하는 것도 중요하지만 우리가 사용하는 웹의 트랜잭션이 어떻게 수행되는지도 때로는 감춰야 할 필요가 있다.  
우리가 어떤 사이트에 가고, 어떤 행동을 하는지등에 대해서 말이다.  
실제로 HTTPS 검열이 이슈가 되었을만큼 웹을 사용하는 사용자들에게는 민감한 주제가 아닐 수 없다.  
트랜잭션 자체를 보호하기 위하여 사용되는 HTTP 암호화에 대해 알아보자.  
  - SSL(Secure Socket Layer)과 TLS(Transport Layer Security)   
  사실 SSL과 TLS는 실제로 HTTP 프로토콜이 동작하는 Application Layer이 아닌 그 아래의 Network Layer에서부터 보안을 제공한다.  
  (TCP영역)  
  따라서 HTTP를 통한 모든 데이터는 TCP 커넥션을 전재로 하기때문에 SSL/TLS의 보안계층을 제공받을 수 있다.  
  
  - HTTPS  
  HTTP에 SSL 커넥션 방식은 대칭/비대칭 인증서 기반의 암호 기법을 결합한 것으로 데이터의 전송단계에서부터 보안을 제공받을 수 있다.  
  실제 SSL 커넥션의 경우 바이너리 프로토콜로 이루어져있기 때문에 SSL 연결 포트인 443에 전달되지 않고 HTTP인 80포트로 갈 시  
  커넥션이 올바르지 않다고 보고 해제될 수 있다.  
  따라서 실제 HTTPS 커넥션의 경우  
  1. 443 포트 TCP 커넥션 연결  
  2. SSL Handshake  
  3. SSL 커넥션 연결  
  4. SSL을 통해 보내는 HTTP 요청 -> TCP를 통해 암호화된 요청  
  5. SSL을 통해 보내진 HTTP 응답 -> TCP를 통해 암호화된 응답  
  6. SSL 커넥션 종료  
  7. TCP 커넥션 종료  
  약 7단계의 방식을 거쳐 이루어지게 된다.  
  
  - 암호화 Key  
  단순히 평문을 인코딩을 통해 암호화 한다면 이 암호화 방식이 유출되는 것은 곧 중요한 데이터가 유출되는 것과 다름이 없다.  
  이러한 암호화 인코딩 방식으 유출되더라도 실제 데이터에 접근할 수 없도록 Key를 통해 인코딩함으로써 디코드할 수 없도록 만들 수 있다.  
    - 대칭키 암호화  
    대칭키 암호화는 인코드/디코드에 사용되는 키가 동일한 알고리즘으로 대칭키 알고리즘을 사용할 때는 키가  
    Brute Force Attack(무차별 대입 공격)에 방어할 수 있도록 충분히 길어야한다.  
    ![image](https://user-images.githubusercontent.com/38939634/65419965-d8e70900-de3a-11e9-82b7-b212243ddda9.png)  
    키의 길이에 따른 무차별 대입공격 소모 시간  
    > [참조](https://www.google.com/url?sa=i&source=images&cd=&ved=2ahUKEwj8qo6G4ubkAhXfw4sBHUsaBUYQjRx6BAgBEAQ&url=https%3A%2F%2Fblog.malwarebytes.com%2Fthreat-analysis%2F2018%2F03%2Fencryption-101-how-to-break-encryption%2F&psig=AOvVaw0utft1AAVR8HSIVYd77jC4&ust=1569321956175848)
    
    - 비대칭키 암호화  
    비대칭키 암호화는 인코딩과 디코딩에 각각 다른 키를 사용하는 방식이다.  
    대칭키의 경우 각 소유자가 인/디코딩 키를 모두 소유해야하기 때문에 하나의 서버에 사용자가 1억명이라면 1억개의 암호화 키가 필요한 단점이 있다.  
    
    - 공개키 암호화  
    비대칭키를 사용한 공개키 암호화 방식은 인코딩 키의 경우 공개되어 있고, 디코딩은 각 호스트가 소유하고있다.  
    따라서 공개키가 있더라도 디코드 키가 없다면 데이터 디코딩은 불가능하다.  
    이러한 공개키 암호화 방식은 웹 상의 모든 사용자가 비대칭 인코딩 키를 가질 수 있게 만들었고 안전한 데이터 전송을 더욱 쉽게 할 수 있게 됐다.  
    
    - 디지털 서명  
    Digital Signing은 메세지를 작성할 때 따라 붙는 Key를 통해 계산된 체크섬이다.  
    키가 없다면 당연히 체크섬을 계산할 수 없고, 이 체크섬은 마치 키를 가지고 있는 소유자가 사용하는 서명과 같이 작동한다.  
    
    - 디지털 인증서  
    디지털 인증서의 경우 이름, 기간, 발급자, 디지털 서명으로 구성되어 있으며 서버는 항상 HTTPS 트랜잭션에서 서버 인증서를 전송해야하기 때문에  
    인증서의 번호, 기간, 이름, 호스트 명, 공개키, 이름, 서명을 제공해주게 된다.  


## 추가자료  
- [OpenSSL](https://ko.wikipedia.org/wiki/OpenSSL)  
- [SSL/TLS](https://smartits.tistory.com/209)  

  
